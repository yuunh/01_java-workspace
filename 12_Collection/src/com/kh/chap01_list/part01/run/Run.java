package com.kh.chap01_list.part01.run;

public class Run {

//	1. 오버로딩 오버라이딩 
//	- 오버로딩 : 한 클래스 내에서 같은 이름의 메소드를 여러 개 정의하는 것
//	- 성립 조건 : 같은 메소드 이름, 다른 매개변수 선언부(매개변수 타입, 개수, 순서)
//
//	- 오버라이딩 : 자식 클래스가 상속받은 부모 메소드를 재작성하는 것
//	- 성립 조건 : 메소드 이름, 매개변수 개수, 매개변수 타입, 리턴 타입 동일
//	- 어노테이션(Annotation) @Override
//
//	2. for문 while문
//	- for문 돌아가는 조건 : 조건식 true일 때
//	- while문이 돌아가는 조건 : 조건식 true일 때
//
//	3. 클래스 다이어그램
//	- 접근제한자
//
//	4. 생성자 : 객체를 생성하기 위한 메소드
//	- 기본생성자 : 자동 (매개변수 생성자를 명시하면 JVM이 기본 생성자를 자동으로 만들어주지 않음 => 기본 생성자 작성 필요
//	- 매개변수생성자 : 내가 만듦
//
//	Phone ph = new Phone();
//	이거 안되는 이유
//
//	5. Exception => 왜나냐?
//
//	------------------------------------
//
//	6. 반복문의 종류 => 어떻게 다른지?
//	- for문
//	- while문 : 초기식 값을 출력할 수 있다
//	- do ~ while문 : 조건문이 true가 아니더라도 무조건 한 번 이상 수행
//
//
//	7. 배열
//	char[] cArr = new char[3];
//	char[] cArr = {'a', 'b', 'c'};
//
//	- 배열 출력
//
//
//	8. for문
//	구구단
//	for (int i = 1; i < 10; i++) {
//				System.out.printf("%d * %d = %d\n", 2, i, 2 * i);
//			}
//
//	9. 배열의 복사
//	- 얕은 복사 : 객체의 주소 값만 가져와 참조형 변수에 저장하고 하나의 객체를 두 변수가 참조하는 것 (주소 값이 같다)
//	- 깊은 복사 : 새로운 배열 객체를 생성하여 기존 배열의 데이터를 복사하는 것 ( 각자 다른 배열 참조하고 있기 때문에 주소 값이 다름)(배열 수정 시 서로에서 영향 X)
//		
//		> for문을 활용한 복사 : 새로운 배열을 생성한 후 반복문을 활용해서 원본 배열의 값들을 새로 만든 배열에 대입한다
//		int[] org = {1, 2, 3, 4, 5};
//		int[] copy = new int[5];
//		for (int i = 0; i < copy.length; i++) {
//			copy[i] = org[i];
//		}
//		
//		> arraycopy() 메소드를 이용한 복사
//		System.arraycopy(원본 배열명, 복사 시작할 인덱스, 복사본 배열명, 복사본 배열의 복사 시작 인덱스, 복사할 개수);
//		int[] org = {1, 2, 3, 4, 5};
//		int[] copy = new int[10];
//		System.arraycopy(org, 1, copy, 3, 3);
//		
//		> copyOf() 메소드를 이용한 복사 : 복사본 배열 = Array.copyOf(원본 배열명, 복사할 길이);
//		int[] org = {1, 2, 3, 4, 5};
//		int[] copy = Array.copyOf(org, 10);
//		
//		> clone() 메소드를 이용한 복사 : 복사본 배열 = 원본배열.clone();
//		int[] org = {1, 2, 3, 4, 5};
//		int[] copy = org.clone();
//
//
//	10. 배열의 특징
//	- 하나의 공간에 여러 개의 값을 담을 수 있다
//	- 같은 자료형의 값으로만 담을 수 있다
//	- 배열의 각 인덱스 자리에 실제 값이 담김
//	- 반복문 활용 가능
//	크기 변경 불가
//
//
//	System.out.print(cArr);
//
//	11. getter / setter
//	- getter : 해당 필드에 담긴 값을 반환해주는 메소드
//	- setter : 해당 필드에 대입시키고자 하는 값 전달받아 해당 필드에 대입시켜주는 메소드
//
//	12. 객체지향 3대 특성
//	- 캡슐화
//	- 상속 + 추상화
//	- 다형성
//
//	13. 변수
//	- 지역변수 : 클래스 영역 내 특정한 구역(메소드, 제어문 등등)에 선언한 변수, 선언된 해당 지역에서만 사용 가능, 지역 변수가 속해있는 특정한 구역 실행시 메모리에 할당, 특정한 구역 종료 시 소멸
//	- 전역변수 : 클래스 영역에 바로 선언한 변수, 클래스 내에서면 어디서든 전역으로 사용 가능
//	- 클래스변수 : == static변수, new 연산자를 통해서 객체 생성 시 메모리에 할당, 객체 소멸 시 같이 소멸
//	- 인스턴스변수 : == 멤버변수, 해당 객체가 생성되지 않더라도, 프로그램 실행과 동시에 메모리에 할당, 프로그램 종료 시 소멸
//
//	14. 접근제한자
//	- public 같은 패키지, 다른 패키지 상관없이 어디서든 접근 가능
//	- protected 같은 패키지 접근 가능, 다른 패키지일 경우 상속구조에서만 접근 가능
//	- default 오로지 같은 패키지에서만 접근 가능
//	- private only 해당 클래스 파일에서만 접근 가능
}
